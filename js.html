<script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
<script>
  const app = new Vue({
    el: '#app',
    vuetify: new Vuetify({
    }),
    data() {
      return {
        appName: 'Sora',
        drawer: false,
        dialogCreateNewFile: false,
        dialogShare: false,
        reveal: false,
        loading: true,
        flipshare: false,
        shareUrl: '',
        syncing: false,
        disable: true,
        themeMode: true,
        filename: null,
        history: {},
        packs: null,
        current: {
          pack: null,
          deck: null,
          card: null,
          discard: [],
          change: false,
        },
        breadcrumb: {
          items: [],
        },
        snackbar: false,
        snackbarText: '',
      };
    },
    async beforeCreate() {
      // google.script.history.setChangeHandler((event) => {
      // event.location.parameters;
      // const name = event.state.name;
      // if (name !== null) {
      //   if (name !== this.flashcardName) {
      //     this.changeFlashcardList(name);
      //   } else {
      //     const card = event.state.card;
      //     if (card !== null) {
      //       this.changeFlashcard(card);
      //     }
      //   }
      // }
      // });
      this.packs = await googleScriptRun('getPacks');
      if (this.packs.length > 0) {
        this.current.pack = this.packs[0];
      }
      // console.log(this.packs);
      // console.log(this.current);
    },
    async created() {
    },
    async mounted() {
      window.addEventListener('beforeunload', this.onBeforeunload);
      document.addEventListener('keydown', this.onKeyup);
    },
    async beforeUnmount() {
      document.removeEventListener('keydown', this.onKeyup);
    },
    computed: {
      isOverlay() {
        return this.dialogCreateNewFile || this.dialogShare;
      },
      enableCurrentPackUrl() {
        if (this.current.pack !== null) {
          return true;
        }
        return false;
      },
      currentPackUrl() {
        if (this.enableCurrentPackUrl) {
          return this.current.pack.url;
        }
        return '';
      },
      currentPackShareUrl() {
        if (this.enableCurrentPackUrl) {
          // if (this.enableCurrentPackUrl && this.current.pack.shareUrl) {
          // console.log(this.current.pack.shareUrl);
          return this.current.pack.shareUrl;
        }
        return '';
      },
      currentId() {
        if (this.current.card !== null) {
          return this.current.card.id;
        }
      },
      currentFront() {
        if (this.current.card !== null) {
          return this.current.card.front;
        }
      },
      currentBack() {
        if (this.current.card !== null) {
          return this.current.card.back;
        }
      },
    },
    watch: {
      'current.pack': {
        async handler(val, old) {
          console.log('change current pack');
          console.log('new: ', val);
          console.log('old: ', old);
          this.breadcrumb.items = [];
          this.breadcrumb.items.push({
            text: val.name
          });
          if (!val.decks) {
            val.decks = await googleScriptRun('getDecks', val);
          }
          if (val.decks.length > 0) {
            this.current.deck = val.decks[0];
          }
          if (val.shareUrl) {
            this.flipshare = true;
            this.shareUrl = val.shareUrl;
          }
        },
      },
      'current.deck': {
        async handler(val, old) {
          console.log('change current deck');
          console.log('new: ', val);
          console.log('old: ', old);
          this.current.card = null;
          if (old !== null) {
            this.breadcrumb.items.pop();
          }
          this.breadcrumb.items.push({
            text: val.name
          });
          if (!val.cards) {
            console.log('getCards');
            val.cards = (await googleScriptRun('getCards', this.current.pack, val)).map(card => new FunctionalCard(card));
            console.log('getCards');
          }
          if (!val.draft) {
            val.draft = val.cards.filter(card => card.isElapsed);
          }
          // if (val.cards.length > 0) {
          //   this.current.card = val.cards[getRandomInt(val.cards.length)];
          // }
          // if (val.draft.length > 0) {
          //   this.current.card = val.draft[getRandomInt(val.draft.length)];
          // }
          console.log('nextQuestion');
          this.nextQuestion();
        },
      },
      'current.card': {
        async handler(val, old) {
          console.log('change current card');
          console.log('new: ', val);
          console.log('old: ', old);
          this.disable = false;
          this.loading = false;
        },
      },
      async themeMode(value, old) {
        this.$vuetify.theme.dark = !value;
      },
    },
    methods: {
      onBeforeunload(event) {
        if (this.change) {
          return confirmLeave(event);
        }
      },
      async onKeyup(event) {
        if (!this.isOverlay) {
          // console.log(event);
          switch (event.key) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
              this.onClickAssessment(parseInt(event.key));
              break;

            case ' ':
              this.flipCard();
              break;

            default:
              break;
          }
        }
      },
      async onClickAssessment(scale) {
        this.change = true;
        const card = this.current.card.evalCard(scale);
        card.lastRepetition = new Date();
        // this.updateMetadata(this.current.pack, this.current.deck, [card]);
        if (scale < 3) {
          this.current.deck.draft.push(card);
        }
        this.current.discard.push(Object.assign(card));
        this.nextQuestion();
      },
      async onClickSyncButton() {
        if (this.current.discard) {
          await this.updateMetadata(this.current.pack, this.current.deck, this.current.discard);
          this.current.discard = [];
          this.change = false;
        }
      },
      async onClickListItem(pack, deck) {
        console.log('pack', pack);
        console.log('deck', deck);
        if (this.current.deck !== deck) {
          // this.loading = true;
          // if (!deck.cards) {
          //   deck.cards = (await googleScriptRun('getCards', pack, deck)).map(card => new FunctionalCard(card));
          // }
          // if (!deck.draft) {
          //   deck.draft = deck.cards.filter(card => card.isElapsed);
          // }
          this.current.deck = deck;
          // this.nextQuestion();
          // this.loading = false;
        }
        this.drawer = false;
      },
      async onClickShareButton() {
        // if (!this.current.pack.shareUrl) {
        this.flipshare = true;
        this.shareUrl = await googleScriptRun('shareFile', this.current.pack);
        this.current.pack.shareUrl = this.shareUrl;
        // console.log(this.current.pack.shareUrl);
        // }
        // console.log(this.current);
      },
      async onClickCopyButton() {
        await navigator.clipboard.writeText(this.currentPackShareUrl);
        // this.dialogShare = false;
        this.showSnackbar('Copied the link.');
      },
      async onClickCancelButton() {
        this.dialogCreateNewFile = false;
      },
      async onClickCreateButton() {
        // console.log(this.filename);
        this.dialogCreateNewFile = false;
        const pack = await googleScriptRun('createNewFile', this.filename);
        // console.log(pack);
        window.open(pack.url, "_blank");
        this.packs.push(pack);
        pack.decks = await googleScriptRun('getDecks', pack);
      },
      async onClickTurn(event) {
        this.flipCard();
      },
      async updateMetadata(pack, deck, cards) {
        this.syncing = true;
        await googleScriptRun('updateMetadata', pack, deck, cards);
        this.syncing = false;
      },
      nextQuestion() {
        // console.log(this.current);
        if (this.current.deck.draft.length) {
          this.loading = true;
          this.disable = true;
          this.turnFront();
          this.current.card = this.current.deck.draft.shift();
          this.disable = false;
          this.loading = false;
        } else {
          console.log('done!');
        }
      },
      flipCard() {
        this.reveal = !this.reveal;
      },
      turnFront(event) {
        this.reveal = false;
        this.disable = false;
      },
      turnBack(event) {
        this.reveal = true;
        this.disable = false;
      },
      showSnackbar(text) {
        this.snackbarText = text;
        this.snackbar = true;
      },
    },
  });

  async function googleScriptRun(name, ...args) {
    return new Promise(function (resolve, reject) {
      google.script.run
        .withSuccessHandler(function (...e) {
          resolve(...e);
        }).withFailureHandler(function (...e) {
          reject(...e);
        })[name](...args);
    });
  }

  function getRandomInt(max) {
    return Math.floor(Math.random() * max);
  }

  function algorithmSM2(q, n, ef, i) {
    if (q < 3) {
      i = 1;
      n = 0;
    } else {
      if (n === 0) {
        i = 1;
      } else if (n === 1) {
        i = 6;
      } else {
        i = Math.ceil(n * ef);
      }
      n += 1;
    }

    ef = ef + (0.1 - (5 - q) * (0.08 + (5 - q) * 0.02));

    if (ef < 1.3) {
      ef = 1.3;
    }

    return {
      n: n,
      ef: ef,
      i: i
    };
  }

  class FunctionalCard {
    constructor(card) {
      this.id = card.id;
      this.front = card.front;
      this.back = card.back;
      this.meta = card.meta;
    }
    evalCard(scale) {
      const result = algorithmSM2(scale, this.meta.repetition, this.meta.efactor, this.interval);
      this.meta.repetition = result.n;
      this.meta.efactor = result.ef;
      this.interval = result.i;
      return this;
    }
    get isElapsed() {
      if (this.meta.lasttime === 0) {
        return true;
      }
      return this.meta.lasttime + this.meta.interval > Date.now();
    }
    get interval() {
      return this.meta.interval / 86400000; // 1000 * 60 * 60 * 24
    }
    set interval(day) {
      this.meta.interval = day * 86400000; // 1000 * 60 * 60 * 24
    }
    get lastRepetition() {
      return new Date(this.meta.lasttime);
    }
    set lastRepetition(date) {
      this.meta.lasttime = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
    }
  }

  function confirmLeave(event) {
    const confirmationMessage = '';
    // Cancel the event as stated by the standard.
    event.preventDefault();
    // Chrome requires returnValue to be set.
    // Gecko + IE
    (event || window.event).returnValue = confirmationMessage;
    // Safari, Chrome, and other WebKit-derived browsers
    return confirmationMessage;
  }
</script>